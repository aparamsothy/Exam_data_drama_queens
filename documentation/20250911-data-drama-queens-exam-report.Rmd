---
title: "RMED901A Exam Report"
author: "Data Drama Queens"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Read and Tidy

The following section is based on the script [20250905-Reading-data.R](https://github.com/aparamsothy/Exam_data_drama_queens/blob/main/script/20250905-Reading-data.R). It shows the process of reading raw patient data, exploring its structure, cleaning duplicates, and tidying data by removing or adding columns and saving the cleaned dataset.

```{r libraries, include=FALSE}
library(tidyverse)
library(here)
library(ggplot2)
```

### Data Reading

The data is read into R as `patient_data`.

```{r Read_dataset, echo=TRUE, results='hide'}
patient_data <- read_delim(
  here("data", "original-data", "exam_data.txt"),
  delim = "\t"
)
```

### Overview of the Data

Next, we want to get a general overview of the data structure. 

```{r Data_overview, include=TRUE}
glimpse(patient_data) # Check structure and types
head(patient_data) # Show first rows
skimr::skim(patient_data) # Summary statistics
naniar::gg_miss_var(patient_data) # Missing data visualization

n_cols_original_data <- ncol(patient_data) # Number of columns
n_rows_original_data <- nrow(patient_data) # Number of rows
```

There are `r n_cols_original_data` columns and `r n_rows_original_data` rows in the original dataset. All columns are numeric, except `mean_RBC_characteristic` (character). We notice that 12 columns have missing data.


### Renaming Columns
The overview of the data indicates that some columns have strange names or can benefit from more intuitive naming. These are renamed.

```{r column_rename}
# Changing column names:
patient_data <- patient_data %>%
  rename(
    # Data friendly names
    neut_percent = `%neut`,
    lymph_percent = `lymph%`,
    age_days = `days of life`,

    # Basic Metabolic Panel (BMP)
    sodium = sod,
    potassium = pot,
    chloride = chlor,
    bicarbonate = co2,
    blood_urea_nitrogen = un,
  )
```

### Removing Duplicate Columns
The overview of the data further indicates that one column is duplicated (`wbc` and `wbc_copy`). The copy is removed.

```{r remove_duplicates}
patient_data <- patient_data %>%
  select(-wbc_copy) # Remove duplicated white blood cell column
```

### Checking Unique Observations
Next, we explore the data to see if there are any duplicated rows.

```{r Row_identification, include=TRUE}
total_obs <- patient_data %>%
  count() %>%
  pull() # Total observations
unique_obs <- patient_data %>%
  distinct(patient_id) %>%
  count() %>%
  pull() # Unique patients
dup_rows <- sum(duplicated(patient_data)) # Number of duplicated rows
```

There are `r unique_obs` unique patient observations out of `r total_obs` rows, indicating duplicated patient IDs in several rows. In addition, `r dup_rows` entire rows are duplicated.

### Creating New Columns by Pivoting

To tidy the data, we create three new characteristics from the `mean_RBC_characteristic` and `mean_value` columns using `pivot_wider()`. Furthermore, duplicates are removed by keeping only distinct rows.

```{r pivoting, include=TRUE}
patient_data <- patient_data %>%
  distinct() %>% # Remove duplicated rows
  pivot_wider(
    names_from = "mean_RBC_characteristic",
    values_from = "mean_value"
  )
```

### Verify Final Data Structure

The dimensions and data types are checked to ensure correct tidying. Now, the data has the expected number of rows and columns. Moreover, all variables are numeric.

```{r Data_verification, include=TRUE}
dim(patient_data) # Expected: 5167 rows, 24 columns
glimpse(patient_data) # Ensure variables are numeric and data is tidy
```



### Saving Tidied Data

The clean and tidy dataset is saved as a text file.

```{r Data_saving, include=TRUE}
filename <- here("data", "data-for-analysis", "20250905-tidy-exam-data.txt")
write_delim(
  patient_data,
  file = filename,
  delim = "\t"
)
```


## Tidy, Adjust and Explore

The following section is based on the script  [20250908-tidy-adjust-explore.data.R](https://github.com/aparamsothy/Exam_data_drama_queens/blob/main/script/20250908-tidy-adjust-explore-data.R). 
In this script we further tidy the data by removing unnecessary columns, join the data with an additional dataset, create new set of variables and order/arrange the variables.

We also explore the dataset by stratifying for variables and reporting statistical characteristics.


### Read the Additional Dataset

We have already read and saved the tidied dataset (`patient_data`) to be used for exploration. Here, we read the additional dataset that we call `patient_data_join`. This will be merged with the tidied dataset.

```{r read_data}
patient_data_join <- read_delim(
  here("data", "original-data", "exam_data_join.txt"),
  delim = "\t"
)
```

### Explore the Joining Dataset

Here we explore the new dataset.

```{r}
glimpse(patient_data_join)
head(patient_data_join)
skimr::skim(patient_data_join)
naniar::gg_miss_var(patient_data_join)

column_count <- ncol(patient_data_join)
column_count

row_count <- patient_data_join %>%
  count() # Number of rows
row_count

patient_data_join %>%
  distinct(patient_id) %>%
  count() # Number of unique patient IDs
```

The joining data appears to have been read correctly. We see that all the columns/variables in the joining dataset are numeric. There are a total of `r row_count` rows/observations and `r column_count` columns. There are two variables (`cal`, `alt`) with missing values. There is the same numbers of rows as unique patient IDs, which suggests that there are no duplicate IDs. The joining dataset which will be joined to our main dataset looks ok.


### Remove Unnessary Variables and Join the Datasets

We remove unnessary columns `hct`and `rdw` and join the two datasets together. By looking at the new combined dataset we see that all the variables are still numeric. Next, we change `active` and `remission` from numerical to factor variables as specified in the received codebook. When looking at the overview of the dataset again, we see that these variables are now factors (see section "Explore the New Dataset After Joining with New Columns").

```{r}
patient_data <- patient_data %>%
  select(-hct, -rdw) %>% # remove variables
  left_join(patient_data_join, join_by("patient_id")) # join the dataset

glimpse(patient_data)

patient_data <- patient_data %>%
  mutate(active = if_else(active == 0, factor("No"), factor("Yes"))) %>% # Factor variable active
  mutate(remission = if_else(remission == 0, factor("No"), factor("Yes"))) # Factor variable remission
```

### Create New Columns

We create five new columns for later use: `hgb_quartiles`, `blood_urea_nitrogen_over_30`, `lymph_count`, `sodium_fraction` and `age_years`. The dataset is arranged so that `age_days` and `blood_urea_nitrogen` comes after `patient_id`. In addition, we arrange the `patient_id` column in increasing order.

```{r}
patient_data <- patient_data %>%
  mutate(hgb_quartiles = cut(hgb, breaks = 4, labels = c("Q1", "Q2", "Q3", "Q4"))) %>% # Cut the hemoglobin level into quartiles
  mutate(blood_urea_nitrogen_over_30 = if_else(blood_urea_nitrogen > 30, factor("Yes"), factor("No"))) %>% # create a column indicating if the blood urea nitrogen is above 30
  mutate(lymph_count = wbc * (lymph_percent / 100)) %>% # add a column for lymphocytes cell count
  mutate(sodium_fraction = (sodium / (sodium + potassium + chloride))) %>% # sodium as a fraction of summed sodium, potassium, and chloride
  select(patient_id, age_days, blood_urea_nitrogen, everything()) %>% # Set the order of columns
  arrange(patient_id) # arrange by patient ID

patient_data <- patient_data %>%
  mutate(age_years = round(age_days / 365.25)) # New variable for age in years
```

### Explore the New Dataset After Joining with New Columns

We count the categorical variables to confirm that they were created correctly. We see from glimpsing the dataset that the new numerical variables seem to be created correctly. There are now 4 factor and 32 numerical variables.

There is most missing data for `blood_urea_nitrogen` and the column created from this (`blood_urea_nitrogen_over_30`). There is also missing values in 15 other columns.

```{r}
patient_data %>%
  count(hgb_quartiles) # Verify that the new column for hemoglobin quartiles makes sense

patient_data %>%
  count(blood_urea_nitrogen_over_30) # Verify that the categorical column for blood urea nitrogen makes sense


glimpse(patient_data)
skimr::skim(patient_data)
naniar::gg_miss_var(patient_data)
```


### Stratification and Report Min, Max, Mean and SD of Variables

Here we answer the provided tasks (copy-pasted from handout):  

1. Stratify the data by `hgb_quartiles` and report min, max, mean and sd of a `rbc`. 
2. Stratify the data by `hgb_quatiles` and report min, max, mean and sd of a `rbc` for a defined set of observations: 

  + Only for persons with hgb \<= 10 
  + Only for persons with remission of inflammation 
  + Only for persons older than around 40 years of age 
  + Only for persons with more than 10% of monocytes in WBC 

3. Use two categorical columns `active` and `remission` in the dataset to create a table

```{r}
# Stratification by hgb_quartiles and report min, max, mean and sd of rbc (red blood cell counts)
patient_data %>%
  group_by(hgb_quartiles) %>%
  summarise(
    min_rbc = min(rbc, na.rm = TRUE),
    max_rbc = max(rbc, na.rm = TRUE),
    mean_rbc = mean(rbc, na.rm = TRUE),
    sd_rbc = sd(rbc, na.rm = TRUE)
  )

# among patients with hgb less than 10
patient_data %>%
  filter(hgb <= 10) %>%
  group_by(hgb_quartiles) %>%
  summarise(
    min_rbc_hgb10 = min(rbc, na.rm = TRUE),
    max_rbc_hgb10 = max(rbc, na.rm = TRUE),
    mean_rbc_hgb10 = mean(rbc, na.rm = TRUE),
    sd_rbc_hgb10 = sd(rbc, na.rm = TRUE)
  )

# among patients with remission of inflammation
patient_data %>%
  filter(remission == "Yes") %>%
  group_by(hgb_quartiles) %>%
  summarise(
    min_rbc_remission = min(rbc, na.rm = TRUE),
    max_rbc_remission = max(rbc, na.rm = TRUE),
    mean_rbc_remission = mean(rbc, na.rm = TRUE),
    sd_rbc_remission = sd(rbc, na.rm = TRUE)
  )

# among patients older than around 40 years of age
patient_data %>%
  group_by(hgb_quartiles) %>%
  filter(age_years > 40) %>% # Previously created age variable
  summarize(
    mean_rbc_age = mean(rbc, na.rm = TRUE),
    min_rbc_age = min(rbc, na.rm = TRUE),
    max_rbc_age = max(rbc, na.rm = TRUE),
    sd_rbc_age = sd(rbc, na.rm = TRUE)
  )

# among patients with more than 10% of monocytes in WBC
patient_data %>%
  group_by(hgb_quartiles) %>%
  filter(mono_percent > 10) %>%
  summarize(
    mean_rbc_mono = mean(rbc, na.rm = TRUE),
    min_rbc_mono = min(rbc, na.rm = TRUE),
    max_rbc_mono = max(rbc, na.rm = TRUE),
    sd_rbc_mono = sd(rbc, na.rm = TRUE)
  )

# Create a table of remission vs active inflammation
table(patient_data$remission, patient_data$active)
```

### Saving the Manipulated Dataset
The newly joined data is saved in a separate file.

```{r}
# Save the joined data ----
filename <- paste0(here("data", "data-for-analysis", "20250908-tidy-joined-exam-data.txt"))
write_delim(
  patient_data,
  file = filename,
  delim = "\t"
)
```

## Creating Plots

The following section is based on the script [20250909-creating-plots.R](https://github.com/aparamsothy/Exam_data_drama_queens/blob/main/script/20250909-creating-plots.R). In this script, we create plots to answer the following provided questions (copy-pasted from handout):

1. Are there any correlated measurements?
2. Does the white blood cell count distribution depend on `pot` (`potassium`)?
3. Does remission of inflammation after Thiopurines for > 12 weeks change with percent of monocytes in WBC count?

The plots are also saved in the original script, but this is not included in this report.

### Correlated Measurements

First, we evaluate the presence of correlated measurements in our dataset. The code and resulting plot are shown below. The plot indicates that some variables are strongly positively correlated, for example:

 * `age_days` and `age_years` (this is reassuring as `age_years` was created as a function of `age_days`.)
 * mean corpuscular (RBC) hemoglobin (`mch`) and mean corpuscular (RBC) volume (`mcv`)
 * Alanine Transaminase (`alt`) and Aspartate Transaminase (`ast`)

We have also some strong negative correlations in the dataset, such as the correlation between Percent of Lymphocytes in WBC count (`lymph_percent`) and Neutrophils in WBC count (`neut_percent`).


```{r corr_plot, warning=FALSE}
# Create correlation plot
GGally::ggcorr(patient_data,
  low = "#2166ac", # colour for negative correlation
  mid = "white", # colour for no correlation
  high = "#b2182b", # colour for positive correlation
  midpoint = 0, # midpoint value
  label = FALSE, # do not add number to the plot
  size = 3 # font size
)
```

### White Blood Cell Count and Potassium

Next, we evaluate if the white blood cell count distribution depends on `potassium`. The code and resulting plot are provided below. From the plot, the white blood cell count does not seem to change with potassium level.

```{r wbc_pot, warning=FALSE, message=FALSE}
# Scatterplot investigating white blood cell count by potassium level ----
ggplot(patient_data, aes(x = wbc, y = potassium)) + # Assign data, x and y values
  geom_point(colour = "darkblue", alpha = 0.5, na.rm = TRUE) + # Scatterplot
  geom_smooth(method = "lm", se = FALSE, colour = "orange") + # Regression line
  theme_minimal() + # Background theme
  theme(
    legend.position = "none", # Remove legend
    plot.title = element_text(face = "bold", size = 12, margin = margin(10, 0, 10, 0)), # Bold title, resized title and increased margin between title and plot
    axis.title.x = element_text(face = "bold", size = 10), # Bold x-axis text
    axis.title.y = element_text(face = "bold", size = 10)
  ) + # Bold y-axis text
  labs(
    title = "White Blood Cell Count by Potassium Level", # Title
    x = "White blood cell count (10,000 cells per microliter)", # x-axis title
    y = "Potassium level (mmol/L)" # y-axis title
  ) 
```

### Remission and Monocytes

Lastly, we evaluate if remission of inflammation after Thiopurines for > 12 weeks change with percent of monocytes in WBC count. The code and resulting plot are shown below. From a visual inspection of the boxplot, there seems to be no difference in percent of monocytes in WBC count for groups with or without remission of inflammation after Thiopurines for > 12 weeks.

```{r}
# Remission and percent of monocytes ----
# Create a boxplot
ggplot(
  data = patient_data,
  mapping = aes(x = remission, y = mono_percent)
) + # select variables
  geom_boxplot(fill = c("#7876B199", "#20854E99")) + # create a box plot and set specific colours
  xlab("Remission") + # change x axis label
  ylab("Monocytes in WBC count (%)") + # y axis labels
  labs(
    title = "Percent of monocytes in WBC count",
    subtitle = "Grouped by remission status"
  ) +
  theme_minimal() + # use the minimal theme
  theme(
    panel.grid.major = element_blank(), # remove major grid
    panel.grid.minor = element_blank(), # remove minor grid
    axis.line = element_line(colour = "grey", linewidth = 0.5), # include x and y axis
    axis.ticks = element_line(colour = "grey", linewidth = 0.5), # include tick marks
    legend.position = "None", # remove legend
    plot.title = element_text(size = 16, face = "bold"), # change title font
    axis.title = element_text(size = 14), # change axis title size
    axis.text.x = element_text(size = 12), # change x-axis text size
    axis.text.y = element_text(size = 12) # change y-axis text size
  )
```

## Statistical Tests

The following section is based on the script [20250910-statistical-analysis.R](https://github.com/aparamsothy/Exam_data_drama_queens/blob/main/script/20250910-statistical-analysis.R).

We perform statistical analyses to answer the following provided questions (copy-pasted from the handout):

1. Does the remission depend on chloride?
2. Is there an association between calcium and total bilirubin?
3. According to the data, was there a difference of alanine transaminase between quartiles of the hemoglobin level?

### Remission and Chloride

Here we investigate if remission depends on chloride levels. We use a t-test to examine this relationship because we have one continuous variable and one dichotomous categorical variable. We have additionally created a boxplot to show the distribution of chloride levels for each category of remission.


```{r}
## Count the number of patients in each category of remission
n_grouped_remission <- patient_data %>%
  group_by(remission) %>%
  count()

n_remission <- n_grouped_remission$n[2]
n_non_remission <- n_grouped_remission$n[1]

## Boxplot to visualize chloride levels by remission status
remission_chloride_plot <- ggplot(patient_data, aes(remission, chloride, color = remission)) + # Assign data, x- and y-variable
  geom_boxplot() + # boxplot
  theme_minimal() + # background theme
  theme(
    legend.position = "none"
  ) + # remove legend
  labs(
    title = "Chloride level by Remission Status",
    x = "Chloride level",
    y = "Remission status"
  ) + # Title to plot, x- and y-axis
  theme(
    axis.title.x = element_text(face = "bold", size = 9),
    axis.title.y = element_text(face = "bold", size = 9),
    plot.title = element_text(hjust = 0.5, size = 12) # Text formatting
  ) +
  scale_color_manual(values = c("No" = "#fe6d01", "Yes" = "#40b0bf")) # Color scheme

# View the plot
remission_chloride_plot

# T-test to test difference in mean chloride levels by remission status
t_test_results <- patient_data %>%
  t.test(chloride ~ remission, data = .) %>%
  broom::tidy()

# View the t-test results
t_test_results
```

The t-test compares the mean of chloride level between those with and without remission. We see from the output that the `r n_remission` patients with remission compared to the `r n_non_remission` patients without remission showed significant difference in chloride levels (t = `r format(t_test_results$estimate, digits=3)`, p = `r format(t_test_results$p.value, scientific = FALSE, digits=1)`).

### Calcium and Total Bilirubin

To investigate if there is an association between calcium and total bilirubin levels, we use a linear regression model because both variables are continuous. Furthermore, we create a scatterplot to visualize the relationship with a linear regression line. 

From the plot we see that the data is not well captured by a linear relationships. Most points are located at low levels of total bilirubin, while only a few points are registered for high levels. If the analysis was to be used in a "real" case, we should consider measures to improve the association evaluation. However, this is believed to be outside the scope of this course.

```{r}
# Plot the data first
cal_tbil_plot <- patient_data %>%
  ggplot(aes(x = tbil, y = cal)) +
  geom_point() +
  geom_smooth(method = "lm") +
  xlab("Total Bilirubin") + # change x axis label
  ylab("Calcium") + # y axis labels
  labs(title = "Association between calcium and total bilirubin") +
  theme_minimal() + # use the minimal theme
  theme(
    panel.grid.major = element_blank(), # remove major grid
    panel.grid.minor = element_blank(), # remove minor grid
    axis.line = element_line(colour = "grey", linewidth = 0.5), # include x and y axis
    axis.ticks = element_line(colour = "grey", linewidth = 0.5), # include tick marks
    plot.title = element_text(size = 16, face = "bold"), # change title font
    axis.title = element_text(size = 14), # change axis title size
    axis.text.x = element_text(size = 12), # change x-axis text size
    axis.text.y = element_text(size = 12) # change y-axis text size
  )

cal_tbil_plot

# Do linear regression
cal_tbil_lm <- patient_data %>%
  lm(cal ~ tbil, data = .) %>%
  broom::tidy()

# View the regression results
cal_tbil_lm
```

The linear regression indicates that there is an association between calcium and total bilirubin. The estimated coefficient is `r format(cal_tbil_lm$estimate[2], digits=3)`, with a p-value of `r format(cal_tbil_lm$p.value[2], digits=1)`.

### Alanine Transaminase and Hemoglobin Levels

We perform an ANOVA test to investigate if there is a difference in alanine transaminase level between quartiles of hemoglobin level because we have one continuous variable and one categorical variable with several categories. Additionally, we create a boxplot to show the distribution of alanine transaminase levels for each quartile of hemoglobin level (with and without extreme outliers to better visualize the relationships).

```{r}
# Plot of Hemoglobin quartiles vs Alanine Transaminase
hgb_alt_plot <- ggplot(patient_data, aes(x = hgb_quartiles, y = alt, fill = hgb_quartiles)) +
  geom_boxplot() + # Creates box plots
  scale_fill_manual(
    values = c("#E31A1C", "#FF7F00", "#1F78B4", "#33A02C"), # Custom colors for each quartile
    name = "Hemoglobin\nQuartiles"
  ) + # Legend title
  labs(
    title = "Alanine Transaminase by Hemoglobin Quartiles", # Main title
    x = "Hemoglobin Quartiles", # X-axis label
    y = "Alanine Transaminase"
  ) + # Y-axis label
  theme_minimal()

hgb_alt_plot

# Plot without extreme outliers
hgb_alt_plot_without_outliers <- ggplot(patient_data, aes(x = hgb_quartiles, y = alt, fill = hgb_quartiles)) +
  geom_boxplot() + # Creates box plots
  scale_fill_manual(
    values = c("#E31A1C", "#FF7F00", "#1F78B4", "#33A02C"), # Custom colors for each quartile
    name = "Hemoglobin\nQuartiles"
  ) + # Legend title
  labs(
    title = "Alanine Transaminase by Hemoglobin Quartiles", # Main title
    x = "Hemoglobin Quartiles", # X-axis label
    y = "Alanine Transaminase"
  ) + # Y-axis label
  theme_minimal() +
  scale_y_continuous(limits = c(0, 200))

hgb_alt_plot_without_outliers


# ANOVA test
hgb_alt_aov <- patient_data %>%
  aov(alt ~ hgb_quartiles, data = .) %>% # Performs one-way ANOVA
  broom::tidy() # Converts results to clean data frame

# View the ANOVA results
hgb_alt_aov
```

The results from the ANOVA does not indicate that there is a significant difference in alanine transaminase level between quartiles of hemoglobin level (p-value = `r format(hgb_alt_aov$p.value[1], digits=1)`).
