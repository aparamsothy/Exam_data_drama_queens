---
title: "RMED901A Exam Report"
author: "Data Drama Queens"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Read and Tidy

------------------------------------------------------------------------


### Introduction

This script form [20250905-Reading-data.R]() shows the process of reading raw patient data, exploring its structure, cleaning duplicates, and tidying data by removing or adding columns and saving the cleaned dataset.

```{r libraries, include=FALSE}
library(tidyverse)
library(here)
library(ggplot2)


```

### Data Reading

To read a text file using `read_delim` and the `here` package for handling file paths, we can use the following script:

```{r Read_dataset, echo=TRUE, results='hide'}
patient_data <- read_delim(
here("data", "original_data", "exam_data.txt"),
delim = "\t"
)
```

### Overview of the data

To get a general view of the data structure, we can use the following script:

```{r Data_overview, include=TRUE}
glimpse(patient_data) # Check structure and types
head(patient_data) # Show first rows
skimr::skim(patient_data) # Summary statistics
naniar::gg_miss_var(patient_data) # Missing data visualization

ncol(patient_data) # Number of columns
nrow(patient_data) # Number of rows
```

### Renaming Columns

To rename columns to consistent names, use `rename()` function.

```{r column_rename, echo=FALSE}
## Changing to specific column names:----
patient_data <- patient_data %>% 
  rename( 
  # Datafriendly names
    neut_percent = `%neut`,           
    lymph_percent = `lymph%`,         
    age_days = `days of life`,
    
    # Basic Metabolic Panel (BMP)
    sodium = sod,                        
    potassium = pot,                     
    chloride = chlor,                    
    bicarbonate = co2,                   
    blood_urea_nitrogen = un,                       
  )
```

### Removing Duplicate Columns

Identify and remove duplicated columns to avoid redundancy by using the following script:

```{r remove duplicates}
patient_data <- patient_data %>%
select(-wbc_copy) # Remove duplicated white blood cell column
```

### Checking Unique Observations

To Count total rows, unique patient IDs, and identify duplicated rows we can use the following script:

```{r Row_identification, include=TRUE}
patient_data %>% count() # Total observations
patient_data %>%
distinct(patient_id) %>%
count() # Unique patients
sum(duplicated(patient_data)) # Number of duplicated rows
```

There are 5167 unique patient observations out of 15524 rows, indicating repeated measurements for some patients. Also 23 duplicated rows exist and will be removed.

### Creating New Columns by Pivoting

To tidy the data format, we can create new characteristic columns using `pivot_wider()` and reshape the data so each patient has one row characteristic column.

Here duplicates are removed by keeping distinct rows.

```{r pivoting, include=TRUE}
patient_data <- patient_data %>%
distinct() %>% # Remove duplicated rows
pivot_wider(
names_from = "mean_RBC_characteristic",
values_from = "mean_value"
)
```

### Verify Final Data Structure

Check the dimensions and data types after tidying.

```{r Data_verification, include=TRUE}
dim(patient_data) # Expected: 5167 rows, 24 columns
glimpse(patient_data) # Ensure variables are double and data is tidy

```

### Saving Tidied Data

Save the cleaned and tidied dataset as a text file using `write_delim()`.

```{r Data_saving, include=TRUE}
filename <- here("data", "data_for_analysis", "20250905-tidy-exam-data.txt")
write_delim(
patient_data,
file = filename,
delim = "\t"
)
```


## Tidy, Adjust and Explore

Following are the codes from the script [20250908-tidy-adjust-explore.data.R](). In this script we have futher tidied the data by removing unnecessary columns, joined with additional dataset, created new set of variables and ordered/arranged the variables.

We have also explored the dataset by stratifying for variables and reporting statistical characteristics of these variables.


### Read the additional dataset

We have already previously read and saved the tidied dataset (`patiend_data`) to be used for exploration. Here we read the additional dataset that we call `patient_data_join` that we will use to merge with the tidied dataset.

```{r read_data}
patient_data_join <- read_delim(
  here("data", "original_data", "exam_data_join.txt"),
  delim = "\t"
)
```

### Explore the joining dataset

Here we explore the new joined dataset.

```{r}
glimpse(patient_data_join)
head(patient_data_join)
skimr::skim(patient_data_join)
naniar::gg_miss_var(patient_data_join)

column_count <- ncol(patient_data_join)
column_count

row_count <- patient_data_join %>%
  count() # Number of rows
row_count

patient_data_join %>%
  distinct(patient_id) %>%
  count() # Number of unique patient IDs
```

The joining data appears to have been read in correctly. We see that all the columns/variables in the joining dataset are numeric. There are a total of `r row_count` rows/observations and `r column_count` columns. There are two variables (`cal`, `alt`) with missing values. There is the same numbers of rows as unique patient IDs which confirms that there are no duplicate IDs. The joining dataset which will be joined to our main dataset looks ok.


### Remove unnessary variables abd join the datasets

We remove unnessary columns `hct`and `rdw` and join the two datasets together. By looking at the new combined dataset we see that all the variables are still numeric. We have changed numerical to factor variables as specified in the codebook. After looking at the overview of the dataset again, we see that the variables `active` and `remission` are now factors.

```{r}
patient_data <- patient_data %>%
 select(-hct, -rdw) %>%  # remove variables
 left_join(patient_data_join, join_by("patient_id")) # join the dataset

glimpse(patient_data)

patient_data <- patient_data %>%
  mutate(active = if_else(active == 0, factor("No"), factor("Yes"))) %>% # Factor variable active
  mutate(remission = if_else(remission == 0, factor("No"), factor("Yes"))) # Factor variable remission
```

### Create new columns

We have created five new columns for later use: `hgb_quartiles`, `blood_ure_nitrogen_over_30`, `lymph_count`, `sodium_fraction` and `age_years`. The dataset have been arranged so that `age_days` and `blood_urea_nitrogen` comes after `patient_id`.

```{r}
patient_data <- patient_data %>% 
  mutate(hgb_quartiles = cut(hgb, breaks=4, labels = c("Q1", "Q2", "Q3", "Q4"))) %>% #Cut the hemoglobin level into quartiles 
  mutate(blood_urea_nitrogen_over_30 = if_else(blood_urea_nitrogen > 30, factor("Yes"), factor("No"))) %>% #create a column indicating if the blood urea nitrogen is above 30
  mutate(lymph_count = wbc * (lymph_percent/100)) %>% #add a column for lymphocytes cell count
  mutate(sodium_fraction = (sodium / (sodium + potassium + chloride))) %>% #sodium as a fraction of summed sodium, potassium, and chloride
  select(patient_id, age_days, blood_urea_nitrogen, everything()) %>% # Set the order of columns
  arrange(patient_id) # arrange by patient ID

patient_data <- patient_data %>%
  mutate(age_years = round(age_days / 365.25)) # New variable for age in years
```

### Explore the new dataset after joining with new columns

We have counted the categorical variables to confirm that they were created correctly. We see from glimpsing the dataset that the new numerical variables seem to be created correctly. There are now 4 factor and 32 numerical variables.

There is most missing data for blood_urea_nitrogen and the column based on this (blood_urea_nitrogen_over_30). There is also missing values for 15 other columns.

```{r}
patient_data %>%
  count(hgb_quartiles) # Verify that the new column for hemoglobin quartiles makes sense

patient_data %>%
  count(blood_urea_nitrogen_over_30) # Verify that the categorical column for blood urea nitrogen makes sense


glimpse(patient_data)
skimr::skim(patient_data)
naniar::gg_miss_var(patient_data)
```


### Stratification and report min, max, mean and sd of variables

Here we answer the following:  

1. Stratify the data by `hgb_quartiles` and report min, max, mean and sd of a `rbc`. 
2. Stratify the by a `hgb_quatiles` and report min, max, mean and sd of a `rbc`` for a defined set of observations: 
+ Only for persons with hgb \<= 10 
+ Only for persons with remission of inflammation 
+ Only for persons older than around 40 years of age 
+ Only for persons with more than 10% of monocytes in WBC 
3. Use two categorical columns `active` and `remission` in the dataset to create a table

```{r}
# Stratification by hgb_quartiles and report min, max, mean and sd of rbc (red blood cell counts)
patient_data %>% 
  group_by(hgb_quartiles) %>%
  summarise(
    min_rbc = min(rbc, na.rm = TRUE),
    max_rbc = max(rbc, na.rm = TRUE),
    mean_rbc = mean(rbc, na.rm = TRUE),
    sd_rbc = sd(rbc, na.rm = TRUE)
  )

# among patients with hgb less than 10
patient_data %>%
  filter(hgb <= 10) %>%  
  group_by(hgb_quartiles) %>%          
  summarise(
    min_rbc_hgb10 = min(rbc, na.rm = TRUE),
    max_rbc_hgb10 = max(rbc, na.rm = TRUE),
    mean_rbc_hgb10 = mean(rbc, na.rm = TRUE),
    sd_rbc_hgb10 = sd(rbc, na.rm = TRUE)
  )

# among patients with remission of inflammation
patient_data %>% 
  filter(remission == "Yes") %>%
  group_by(hgb_quartiles) %>%
  summarise(
    min_rbc_remission = min(rbc, na.rm = TRUE),
    max_rbc_remission = max(rbc, na.rm = TRUE),
    mean_rbc_remission = mean(rbc, na.rm = TRUE),
    sd_rbc_remission = sd(rbc, na.rm = TRUE)
  )

# among patients older than around 40 years of age
patient_data %>%
  group_by(hgb_quartiles) %>%
  filter(age_years > 40) %>% # Previously created age variable
  summarize(mean_rbc_age = mean(rbc, na.rm = TRUE),
            min_rbc_age = min(rbc, na.rm = TRUE),
            max_rbc_age = max(rbc, na.rm = TRUE),
            sd_rbc_age = sd(rbc, na.rm = TRUE))

# among patients with more than 10% of monocytes in WBC
patient_data %>%
  group_by(hgb_quartiles) %>%
  filter(mono_percent > 10) %>%
  summarize(mean_rbc_mono = mean(rbc, na.rm = TRUE),
            min_rbc_mono = min(rbc, na.rm = TRUE),
            max_rbc_mono = max(rbc, na.rm = TRUE),
            sd_rbc_mono = sd(rbc, na.rm = TRUE))

# Create a table of remission vs active inflammation
table(patient_data$remission, patient_data$active)
```

### Saving the manipulated dataset

```{r}
# Save the joined data ----
filename <- paste0(here("data", "data_for_analysis", "20250908-tidy-joined-exam-data.txt"))
write_delim(
  patient_data, 
  file = filename,
  delim = "\t"
)
```

## Creating Plots

We have created plots to answer the following questions:<br /> 1. Are there any correlated measurements?<br /> 2. Does the white blood cell count distribution depend on pot?<br /> 3. Does remission of inflammation after Thiopurines for \> 12 weeks change with percent of monocytes in WBC count?<br />

The analysis was conducted in the script [20250909-creating_plots.R]()

### Correlated measurements

First, we evaluated the presence of correlated measurements in our dataset. The code and resulting plot are shown below. The plot indicates that some variables are strongly correlated. As an example, we see that `age_days` and `age_years` are strongly correlated. This is reassuring as `age_years` was created as a function of `age_days`. We can also see that mean corpuscular (RBC) hemoglobin (`mch`) and mean corpuscular (RBC) volume (`mcv`), as well as Alanine Transaminase (`alt`) and Aspartate Transaminase (`ast`) are strongly correlated. In addition, we see that the percent of Lymphocytes in WBC count (`lymph_percent`) is strongly negatively correlated with percent of Neutrophils in WBC count (`neut_percent`).


```{r corr_plot, warning=FALSE}
# Create correlation plot
GGally::ggcorr(patient_data,
                           low = "#2166ac",
                           mid = "white",
                           high = "#b2182b",
                           midpoint = 0,
                           label = FALSE,
                           size = 3)

```

### White Blood Cell Count and Potassium

Next, we evaluated if the white blood cell count distribution depends on `potassium`. The code and resulting plot are provided below. From the plot, the white blood cell count does not seem to change with potassium level.

```{r wbc_pot, warning=FALSE, message=FALSE}
# Scatterplot investigating white blood cell count by potassium level ----
ggplot(patient_data, aes(x = wbc, y = potassium)) + # Assign data, x and y values
  geom_point(colour = "darkblue", alpha = 0.5, na.rm = TRUE) + # Scatterplot
  geom_smooth(method = "lm", se = FALSE, colour = "orange") + #Regression line
  theme_minimal() + #Background theme
  theme(legend.position = "none", #Remove legend
        plot.title = element_text(face = "bold", size = 12, margin = margin(10, 0, 10, 0)), #Bold title, resized title and increased margin between title and plot
        axis.title.x = element_text(face = "bold", size = 10), #Bold x-axis text
        axis.title.y = element_text(face = "bold", size = 10)) + #Bold y-axis text
  labs(title = "White Blood Cell Count by Potassium Level", #Title
       x = "White blood cell count (10,000 cells per microliter)", #x-axis title
       y = "Potassium level (mmol/L)") #y-axis title

```

### Remission and Monocytes

Lastly, we evaluated if remission of inflammation after Thiopurines for \> 12 weeks change with percent of monocytes in WBC count. The code and resulting plot are shown below. From a visual inspection of the boxplot, there seems to be no difference in percent of monocytes in WBC count for groups with or without remission of inflammation after Thiopurines for \> 12 weeks.

```{r}
# Remission and percent of monocytes ----
# Create a boxplot
ggplot(data=patient_data, 
                              mapping=aes(x=remission, y=mono_percent)) + #select variables
  geom_boxplot(fill=c("#7876B199", "#20854E99")) + #create a box plot and set specific colours
  xlab("Remission") + #change x axis label
  ylab("Monocytes in WBC count (%)") + #y axis labels
  labs(title = "Percent of monocytes in WBC count",
       subtitle = "Grouped by remission status") +
  theme_minimal() + #use the minimal theme
  theme(
    panel.grid.major = element_blank(), #remove major grid
    panel.grid.minor = element_blank(), #remove minor grid
    axis.line = element_line(colour="grey", linewidth = 0.5), #include x and y axis
    axis.ticks = element_line(colour = "grey", linewidth = 0.5), #include tick marks
    legend.position = "None", #remove legend
    plot.title = element_text(size = 16, face = "bold"), #change title font
    axis.title = element_text(size = 14), #change axis title size
    axis.text.x = element_text( size = 12), #change x-axis text size
    axis.text.y = element_text(size=12) #change y-axis text size
  ) 
  
 

```

## Statistical Tests

We have performed statistical analyses to answer the following questions:

1. Does the remission depend on chloride?
2. Is there an association between calcium and total bilirubin?
3. According to the data, was there a difference of alanine transaminase between quartiles of the hemoglobin level?


### Alanine transaminase and hemoglobin levels

We decided to perform an ANOVA test to investigate if there is a difference of alanine transaminase level between quartiles of hemoglobin level because we have one continuous variable and one categorical variable with several categories. Additionally created a boxplot to show the distribution of alanine transaminase levels for each quartile of hemoglobin level (with and without outliers to better visualize the relationships). There results from the ANOVA does not indicate that there is a significant difference.

```{r}
# ANOVA test
hgb_alt_aov <-patient_data %>% 
  aov(alt ~ hgb_quartiles, data = .) %>%# Performs one-way ANOVA
  broom::tidy() # Converts results to clean data frame

# View the ANOVA results
hgb_alt_aov

# Plot 1 - Hemoglobin quartiles vs Alanine Transaminase
hgb_alt_plot <- ggplot(patient_data, aes(x = hgb_quartiles, y = alt, fill = hgb_quartiles)) +
  geom_boxplot() + # Creates box plots
  scale_fill_manual(values = c("#E31A1C", "#FF7F00", "#1F78B4", "#33A02C"), # Custom colors for each quartile
                    name = "Hemoglobin\nQuartiles") + # Legend title 
  labs(title = "Alanine Transaminase by Hemoglobin Quartiles", # Main title
       x = "Hemoglobin Quartiles", # X-axis label
       y = "Alanine Transaminase") + # Y-axis label
  theme_minimal()                         

hgb_alt_plot

# Save plot as PNG
filename_correlation_plot <- here("figures", "hgb_alt_plot.tiff")
ggsave(filename_correlation_plot, plot = hgb_alt_plot, width = 7, height = 7, dpi = 300)


hgb_alt_plot_without_outliers <- ggplot(patient_data, aes(x = hgb_quartiles, y = alt, fill = hgb_quartiles)) +
  geom_boxplot() + # Creates box plots
  scale_fill_manual(values = c("#E31A1C", "#FF7F00", "#1F78B4", "#33A02C"), # Custom colors for each quartile
                    name = "Hemoglobin\nQuartiles") + # Legend title 
  labs(title = "Alanine Transaminase by Hemoglobin Quartiles", # Main title
       x = "Hemoglobin Quartiles", # X-axis label
       y = "Alanine Transaminase") + # Y-axis label
  theme_minimal() +
  scale_y_continuous(limits = c(0, 200))

hgb_alt_plot_without_outliers

# Save plot as PNG
filename_correlation_plot <- here("figures", "hgb_alt_plot_without_outliers.tiff")
ggsave(filename_correlation_plot, plot = hgb_alt_plot_without_outliers, width = 7, height = 7, dpi = 300)
```


### Remission and chloride

Here we investigate if remission is depended in chloride levels, and decided to use a t-test because we have one continuous variable and one dichotomous categorical variable. We have additionally created a boxplot to show the distribution of chloride levels for each category of remission.

The T-test compares the mean of chloride level between those with and without remission. We see from the output that the 2808 patients with remission compared to the 2359 patients without remission showed significant difference in chloride levels (t = -0.377, p = 0.000113).


```{r}
## Count the number of patients in each category of remission
patient_data %>%
  group_by(remission) %>%
  count()

## Boxplot to visualize chloride levels by remission status
remission_chloride_plot <- ggplot(patient_data, aes(remission, chloride, color = remission)) +
  geom_boxplot() +
  theme_minimal() +
  theme(
    legend.position = "none"
  ) +
  labs(title = "Chloride level by Remission Status",
       x = "Chloride level",
       y = "Remission status") +
  theme(
    axis.title.x = element_text(face = "bold", size = 9),
    axis.title.y = element_text(face = "bold", size = 9),
    plot.title = element_text(hjust = 0.5, size = 12)
  ) +
  scale_color_manual(values = c("No" = "#fe6d01", "Yes" = "#40b0bf"))

remission_chloride_plot

# Save plot as PNG
filename_correlation_plot <- here("figures", "remission_chloride.tiff")
ggsave(filename_correlation_plot, plot = remission_chloride_plot, width = 7, height = 7, dpi = 300)


# T-test to test difference in mean chloride levels by remission status
t_test_results <- patient_data %>% 
  t.test(chloride ~ remission, data = .) %>%
  broom::tidy()

# View the t-test results
t_test_results
```


### Calcium and total bilirubin

To investigate if there is an association between calcium and total bilirubin levels, we have used a linear regression model because both variables are continuous. Furthermore, we have created a scatterplot in order the visualize the relationship between both variables with a linear regression line. 

From the plot we see that the data is not well captured by a linear relationships. Most points are located at low levels of total bilirubin, while a few points are located to the right. If the analyse was to be used in a "real" analysis, we should consider measures to improve the association evaluation.

However, a linear regression analysis for the association between calcium and total bilirubin isconsidered to be sufficient in this project.

The linear regression indicates that there is an association between calcium and total bilirubin. The estimated coefficient is -0.09, with a p-value of 1.8e-104.


```{r}
#Plot the data first
cal_tbil_plot <- patient_data  %>%
  ggplot(aes(x = tbil, y = cal)) +
  geom_point() +
  geom_smooth(method = "lm") +
  xlab("Total Bilirubin") + #change x axis label
  ylab("Calcium") + #y axis labels
  labs(title = "Association between calcium and total bilirubin") +
  theme_minimal() + #use the minimal theme
  theme(
    panel.grid.major = element_blank(), #remove major grid
    panel.grid.minor = element_blank(), #remove minor grid
    axis.line = element_line(colour="grey", linewidth = 0.5), #include x and y axis
    axis.ticks = element_line(colour = "grey", linewidth = 0.5), #include tick marks
    plot.title = element_text(size = 16, face = "bold"), #change title font
    axis.title = element_text(size = 14), #change axis title size
    axis.text.x = element_text( size = 12), #change x-axis text size
    axis.text.y = element_text(size=12) #change y-axis text size
  ) 

cal_tbil_plot

# Save plot as PNG
filename_correlation_plot <- here("figures", "cal_tbil.tiff")
ggsave(filename_correlation_plot, plot = cal_tbil_plot, width = 7, height = 7, dpi = 300)


cal_tbil_lm <- patient_data %>% 
  lm(cal ~ tbil, data = .) %>%
  broom::tidy()

# View the regression results
cal_tbil_lm

```

